#!/usr/bin/env python3
#
# Copyright 2025 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Generates the vkjson files.
"""
import os
import generator_common as gencom
import vkjson_gen_util as util
import vk as VK
import importlib

VK_PROPERTIES_SETTER_LINE = 'vkGetPhysicalDeviceProperties2(physical_device, &properties);'

def re_import_vk():
  importlib.reload(VK)

def gen_h():
  """Generates vkjson.h file.
  """
  genfile = os.path.join(os.path.dirname(__file__),
                         "..", "vkjson", "vkjson.h")

  with open(genfile, "w") as f:
    f.write(f'{util.get_copyright_warnings()}\n')

    f.write("""\
#ifndef VKJSON_H_
#define VKJSON_H_

#ifndef VK_USE_PLATFORM_ANDROID_KHR
#define VK_USE_PLATFORM_ANDROID_KHR
#endif

#include <string.h>
#include <vulkan/vulkan.h>

#include <map>
#include <string>
#include <vector>

#ifdef WIN32
#undef min
#undef max
#endif

/*
 * This file is autogenerated by vkjson_generator.py. Do not edit directly.
 */
struct VkJsonLayer {
  VkLayerProperties properties;
  std::vector<VkExtensionProperties> extensions;
};

\n""")

    vkjson_extension_structs = util.generate_extension_struct_definition(f)
    vkjson_core_structs = util.generate_vk_core_struct_definition(f)

    f.write("""\
struct VkJsonDevice {
  VkJsonDevice() {""")

    feature_property_structs = util.generate_memset_statements(f)

    f.write("""\
  }\n""")
    for struct_entries in (vkjson_extension_structs, vkjson_core_structs, feature_property_structs):
      for entry in struct_entries:
        f.write(entry + ";\n")

    # write list properties for memory allocation
    list_members = util.get_dynamic_size_list_member_from_structures(VK.EXTENSION_INDEPENDENT_STRUCTS)
    for list_type, list_variable_name in list_members:
      variable_entry = "std::vector<" + list_type + ">" + " " + list_variable_name + ";"
      f.write(f"  {variable_entry}\n")

    f.write("""\
  std::vector<VkQueueFamilyProperties> queues;
  std::vector<VkExtensionProperties> extensions;
  std::vector<VkLayerProperties> layers;
  std::map<VkFormat, VkFormatProperties> formats;
  std::map<VkExternalFenceHandleTypeFlagBits, VkExternalFenceProperties>
      external_fence_properties;
  std::map<VkExternalSemaphoreHandleTypeFlagBits, VkExternalSemaphoreProperties>
      external_semaphore_properties;
};

struct VkJsonDeviceGroup {
  VkJsonDeviceGroup() {
    memset(&properties, 0, sizeof(VkPhysicalDeviceGroupProperties));
  }
  VkPhysicalDeviceGroupProperties properties;
  std::vector<uint32_t> device_inds;
};

struct VkJsonInstance {
  VkJsonInstance() : api_version(0) {}
  uint32_t api_version;
  std::vector<VkJsonLayer> layers;
  std::vector<VkExtensionProperties> extensions;
  std::vector<VkJsonDevice> devices;
  std::vector<VkJsonDeviceGroup> device_groups;
};

VkJsonInstance VkJsonGetInstance();
std::string VkJsonInstanceToJson(const VkJsonInstance& instance);
bool VkJsonInstanceFromJson(const std::string& json,
                            VkJsonInstance* instance,
                            std::string* errors);

VkJsonDevice VkJsonGetDevice(VkPhysicalDevice device);
std::string VkJsonDeviceToJson(const VkJsonDevice& device);
bool VkJsonDeviceFromJson(const std::string& json,
                          VkJsonDevice* device,
                          std::string* errors);

std::string VkJsonImageFormatPropertiesToJson(
    const VkImageFormatProperties& properties);
bool VkJsonImageFormatPropertiesFromJson(const std::string& json,
                                         VkImageFormatProperties* properties,
                                         std::string* errors);

// Backward-compatibility aliases
typedef VkJsonDevice VkJsonAllProperties;
inline VkJsonAllProperties VkJsonGetAllProperties(
    VkPhysicalDevice physicalDevice) {
  return VkJsonGetDevice(physicalDevice);
}
inline std::string VkJsonAllPropertiesToJson(
    const VkJsonAllProperties& properties) {
  return VkJsonDeviceToJson(properties);
}
inline bool VkJsonAllPropertiesFromJson(const std::string& json,
                                        VkJsonAllProperties* properties,
                                        std::string* errors) {
  return VkJsonDeviceFromJson(json, properties, errors);
}

#endif  // VKJSON_H_""")

    f.close()
  gencom.run_clang_format(genfile)


def gen_cc():
  """Generates vkjson.cc file.
  """
  genfile = os.path.join(os.path.dirname(__file__),
                         "..", "vkjson", "vkjson.cc")

  with open(genfile, "w") as f:

    f.write(util.get_copyright_warnings())
    f.write("\n")

    f.write("""\
#include "vkjson.h"

#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include <json/json.h>

#include <algorithm>
#include <cinttypes>
#include <cmath>
#include <cstdio>
#include <limits>
#include <memory>
#include <sstream>
#include <type_traits>
#include <utility>

/*
 * This file is autogenerated by vkjson_generator.py. Do not edit directly.
 */
namespace {

/*
 * Annotation to tell clang that we intend to fall through from one case to
 * another in a switch. Sourced from android-base/macros.h.
 */
#define FALLTHROUGH_INTENDED [[clang::fallthrough]]

inline bool IsIntegral(double value) {
#if defined(ANDROID)
  // Android NDK doesn't provide std::trunc yet
  return trunc(value) == value;
#else
  return std::trunc(value) == value;
#endif
}

// Floating point fields of Vulkan structure use single precision. The string
// output of max double value in c++ will be larger than Java double's infinity
// value. Below fake double max/min values are only to serve the safe json text
// parsing in between C++ and Java, because Java json library simply cannot
// handle infinity.
static const double SAFE_DOUBLE_MAX = 0.99 * std::numeric_limits<double>::max();
static const double SAFE_DOUBLE_MIN = -SAFE_DOUBLE_MAX;

template <typename T> struct EnumTraits;

template <>
struct EnumTraits<VkImageLayout> {
  static bool exist(uint32_t e) {
    switch (e) {
      case VK_IMAGE_LAYOUT_UNDEFINED:
      case VK_IMAGE_LAYOUT_GENERAL:
      case VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:
      case VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL:
      case VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL:
      case VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:
      case VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:
      case VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:
      case VK_IMAGE_LAYOUT_PREINITIALIZED:
      case VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL:
      case VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL:
      case VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL:
      case VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL:
      case VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL:
      case VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL:
      case VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL:
      case VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL:
      case VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:
      case VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR:
      case VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR:
      case VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR:
      case VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR:
      case VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT:
      case VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR:
#ifdef VK_ENABLE_BETA_EXTENSIONS
      case VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR:
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
      case VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR:
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
      case VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR:
#endif
      case VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT:
        return true;
    }
    return false;
  }
};
\n\n""")
    f.write(f"{util.generate_enum_traits()}")
    f.write("""
template <typename Visitor>
inline bool Iterate(Visitor* visitor, VkExtent3D* extents) {
  return
    visitor->Visit("width", &extents->width) &&
    visitor->Visit("height", &extents->height) &&
    visitor->Visit("depth", &extents->depth);
}

template <typename Visitor>
inline bool Iterate(Visitor* visitor,
                    VkPhysicalDeviceLayeredApiPropertiesKHR* properties) {
  return
      visitor->Visit("vendorID", &properties->vendorID) &&
      visitor->Visit("deviceID", &properties->deviceID) &&
      visitor->Visit("layeredAPI", &properties->layeredAPI) &&
      visitor->Visit("deviceName", &properties->deviceName);
}

template <typename Visitor>
inline bool Iterate(Visitor* visitor, VkExtent2D* extents) {
  return
    visitor->Visit("width", &extents->width) &&
    visitor->Visit("height", &extents->height);
}

template <typename Visitor>
inline bool Iterate(Visitor* visitor,
                    VkConformanceVersionKHR* version) {
  return visitor->Visit("major", &version->major) &&
         visitor->Visit("minor", &version->minor) &&
         visitor->Visit("subminor", &version->subminor) &&
         visitor->Visit("patch", &version->patch);
}

template <typename Visitor>
inline bool Iterate(Visitor* visitor, VkMemoryType* type) {
  return
    visitor->Visit("propertyFlags", &type->propertyFlags) &&
    visitor->Visit("heapIndex", &type->heapIndex);
}

template <typename Visitor>
inline bool Iterate(Visitor* visitor, VkMemoryHeap* heap) {
  return
    visitor->Visit("size", &heap->size) &&
    visitor->Visit("flags", &heap->flags);
}\n\n""")

    f.write(f"{util.generate_core_template()}\n\n{util.generate_extension_struct_template()}\n\n")
    f.write(util.generate_struct_template(VK.ALL_STRUCTS_EXTENDING_FEATURES_OR_PROPERTIES))
    f.write(util.generate_struct_template(VK.VULKAN_API_1_0_STRUCTS))
    f.write("""\
template <typename Visitor>
inline bool Iterate(Visitor* visitor, VkExternalFenceProperties* properties) {
  return visitor->Visit("exportFromImportedHandleTypes",
                        &properties->exportFromImportedHandleTypes) &&
         visitor->Visit("compatibleHandleTypes",
                        &properties->compatibleHandleTypes) &&
         visitor->Visit("externalFenceFeatures",
                        &properties->externalFenceFeatures);
}

template <typename Visitor>
inline bool Iterate(Visitor* visitor,
                    VkExternalSemaphoreProperties* properties) {
  return visitor->Visit("exportFromImportedHandleTypes",
                        &properties->exportFromImportedHandleTypes) &&
         visitor->Visit("compatibleHandleTypes",
                        &properties->compatibleHandleTypes) &&
         visitor->Visit("externalSemaphoreFeatures",
                        &properties->externalSemaphoreFeatures);
}

template <typename Visitor>
inline bool Iterate(Visitor* visitor, VkJsonLayer* layer) {
  return visitor->Visit("properties", &layer->properties) &&
         visitor->Visit("extensions", &layer->extensions);
}

template <typename Visitor>
inline bool Iterate(Visitor* visitor, VkJsonDeviceGroup* device_group) {
  return visitor->Visit("devices", &device_group->device_inds) &&
         visitor->Visit("subsetAllocation",
                        &device_group->properties.subsetAllocation);
}

template <typename Visitor>
inline bool Iterate(Visitor* visitor, VkJsonDevice* device) {
  bool ret = true;
  switch (device->properties.apiVersion ^
          VK_API_VERSION_PATCH(device->properties.apiVersion)) {
    case VK_API_VERSION_1_4:
      ret &=
      """)
     # TODO:- b/415707479 (Update generator to handle new Vulkan API versions automatically.)
    util.emit_struct_visits_by_vk_version(f, "VK_VERSION_1_4")
    f.write("""visitor->Visit("core14", &device->core14);
      FALLTHROUGH_INTENDED;
    case VK_API_VERSION_1_3:
      ret &= """)
    util.emit_struct_visits_by_vk_version(f, "VK_VERSION_1_3")
    f.write("""visitor->Visit("core13", &device->core13);
      FALLTHROUGH_INTENDED;
    case VK_API_VERSION_1_2:
      ret &=
            """)
    util.emit_struct_visits_by_vk_version(f, "VK_VERSION_1_2")
    f.write("""
      visitor->Visit("core11", &device->core11);
      ret &= visitor->Visit("core12", &device->core12);
      FALLTHROUGH_INTENDED;
    case VK_API_VERSION_1_1:
      ret &=\n""")

    util.emit_struct_visits_by_vk_version(f, "VK_VERSION_1_1")

    f.write("""\
          visitor->Visit("externalFenceProperties",
                         &device->external_fence_properties) &&
          visitor->Visit("externalSemaphoreProperties",
                         &device->external_semaphore_properties);
      FALLTHROUGH_INTENDED;
    case VK_API_VERSION_1_0:
      ret &=\n""")

    util.emit_struct_visits_by_vk_version(f, "VK_VERSION_1_0")

    f.write("""\
             visitor->Visit("properties", &device->properties) &&
             visitor->Visit("features", &device->features) &&
             visitor->Visit("memory", &device->memory) &&
             visitor->Visit("queues", &device->queues) &&
             visitor->Visit("extensions", &device->extensions) &&
             visitor->Visit("layers", &device->layers) &&
             visitor->Visit("formats", &device->formats);\n\n""")

    for extension_name, _ in VK.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING["extensions"].items():
      struct_var = util.get_vkjson_struct_variable_name(extension_name)
      f.write(f"  if (device->{struct_var}.reported) {{\n")
      f.write(f"    ret &= visitor->Visit(\"{extension_name}\", &device->{struct_var});\n")
      f.write("  }\n")

    f.write("""\
    } return ret; }

template <typename Visitor>
inline bool Iterate(Visitor* visitor, VkJsonInstance* instance) {
  bool ret = true;
  switch (instance->api_version ^ VK_API_VERSION_PATCH(instance->api_version)) {
    case VK_API_VERSION_1_4:
      FALLTHROUGH_INTENDED;
    case VK_API_VERSION_1_3:
      FALLTHROUGH_INTENDED;
    case VK_API_VERSION_1_2:
      ret &= visitor->Visit("apiVersion", &instance->api_version);
      FALLTHROUGH_INTENDED;
    case VK_API_VERSION_1_1:
      ret &= visitor->Visit("deviceGroups", &instance->device_groups);
      FALLTHROUGH_INTENDED;
    case VK_API_VERSION_1_0:
      ret &= visitor->Visit("layers", &instance->layers) &&
             visitor->Visit("extensions", &instance->extensions) &&
             visitor->Visit("devices", &instance->devices);
  }
  return ret;
}

template <typename T>
using EnableForArithmetic =
    typename std::enable_if<std::is_arithmetic<T>::value, void>::type;

template <typename T>
using EnableForStruct =
    typename std::enable_if<std::is_class<T>::value, void>::type;

template <typename T>
using EnableForEnum =
    typename std::enable_if<std::is_enum<T>::value, void>::type;

template <typename T, typename = EnableForStruct<T>, typename = void>
Json::Value ToJsonValue(const T& value);

template <typename T, typename = EnableForArithmetic<T>>
inline Json::Value ToJsonValue(const T& value) {
  return Json::Value(
      std::clamp(static_cast<double>(value), SAFE_DOUBLE_MIN, SAFE_DOUBLE_MAX));
}

inline Json::Value ToJsonValue(const uint64_t& value) {
  char string[19] = {0};  // "0x" + 16 digits + terminal \\0
  snprintf(string, sizeof(string), "0x%016" PRIx64, value);
  return Json::Value(string);
}

template <typename T, typename = EnableForEnum<T>, typename = void,
          typename = void>
inline Json::Value ToJsonValue(const T& value) {
  return Json::Value(static_cast<double>(value));
}

template <typename T>
inline Json::Value ArrayToJsonValue(uint32_t count, const T* values) {
  Json::Value array(Json::arrayValue);
  for (unsigned int i = 0; i < count; ++i) array.append(ToJsonValue(values[i]));
  return array;
}

template <typename T, size_t N>
inline Json::Value ToJsonValue(const T (&value)[N]) {
  return ArrayToJsonValue(N, value);
}

template <size_t N>
inline Json::Value ToJsonValue(const char (&value)[N]) {
  assert(strlen(value) < N);
  return Json::Value(value);
}

template <typename T>
inline Json::Value ToJsonValue(const std::vector<T>& value) {
  assert(value.size() <= std::numeric_limits<uint32_t>::max());
  return ArrayToJsonValue(static_cast<uint32_t>(value.size()), value.data());
}

template <typename F, typename S>
inline Json::Value ToJsonValue(const std::pair<F, S>& value) {
  Json::Value array(Json::arrayValue);
  array.append(ToJsonValue(value.first));
  array.append(ToJsonValue(value.second));
  return array;
}

template <typename F, typename S>
inline Json::Value ToJsonValue(const std::map<F, S>& value) {
  Json::Value array(Json::arrayValue);
  for (auto& kv : value) array.append(ToJsonValue(kv));
  return array;
}

class JsonWriterVisitor {
 public:
  JsonWriterVisitor() : object_(Json::objectValue) {}

  ~JsonWriterVisitor() {}

  template <typename T> bool Visit(const char* key, const T* value) {
    object_[key] = ToJsonValue(*value);
    return true;
  }

  template <typename T, uint32_t N>
  bool VisitArray(const char* key, uint32_t count, const T (*value)[N]) {
    assert(count <= N);
    object_[key] = ArrayToJsonValue(count, *value);
    return true;
  }

  template <typename T>
  bool VisitArray(const char* key, uint32_t count, const T *value) {
    object_[key] = ArrayToJsonValue(count, *value);
    return true;
  }

  Json::Value get_object() const { return object_; }

 private:
  Json::Value object_;
};

template <typename Visitor, typename T>
inline void VisitForWrite(Visitor* visitor, const T& t) {
  Iterate(visitor, const_cast<T*>(&t));
}

template <typename T, typename /*= EnableForStruct<T>*/, typename /*= void*/>
Json::Value ToJsonValue(const T& value) {
  JsonWriterVisitor visitor;
  VisitForWrite(&visitor, value);
  return visitor.get_object();
}

template <typename T, typename = EnableForStruct<T>>
bool AsValue(Json::Value* json_value, T* t);

inline bool AsValue(Json::Value* json_value, int32_t* value) {
  if (json_value->type() != Json::realValue) return false;
  double d = json_value->asDouble();
  if (!IsIntegral(d) ||
      d < static_cast<double>(std::numeric_limits<int32_t>::min()) ||
      d > static_cast<double>(std::numeric_limits<int32_t>::max()))
    return false;
  *value = static_cast<int32_t>(d);
  return true;
}

inline bool AsValue(Json::Value* json_value, int64_t* value) {
  if (json_value->type() != Json::realValue)
    return false;
  double d = json_value->asDouble();
  if (!IsIntegral(d) ||
      d < static_cast<double>(std::numeric_limits<int64_t>::min()) ||
      d > static_cast<double>(std::numeric_limits<int64_t>::max()))
    return false;
  *value = static_cast<int64_t>(d);
  return true;
}

inline bool AsValue(Json::Value* json_value, uint64_t* value) {
  if (json_value->type() != Json::stringValue) return false;
  int result =
      std::sscanf(json_value->asString().c_str(), "0x%016" PRIx64, value);
  return result == 1;
}

inline bool AsValue(Json::Value* json_value, uint32_t* value) {
  if (json_value->type() != Json::realValue) return false;
  double d = json_value->asDouble();
  if (!IsIntegral(d) || d < 0.0 ||
      d > static_cast<double>(std::numeric_limits<uint32_t>::max()))
    return false;
  *value = static_cast<uint32_t>(d);
  return true;
}

inline bool AsValue(Json::Value* json_value, uint8_t* value) {
  uint32_t value32 = 0;
  AsValue(json_value, &value32);
  if (value32 > std::numeric_limits<uint8_t>::max())
    return false;
  *value = static_cast<uint8_t>(value32);
  return true;
}

inline bool AsValue(Json::Value* json_value, float* value) {
  if (json_value->type() != Json::realValue) return false;
  *value = static_cast<float>(json_value->asDouble());
  return true;
}

inline bool AsValue(Json::Value* json_value, VkImageLayout* t) {
  uint32_t value = 0;
  if (!AsValue(json_value, &value))
    return false;
  if (!EnumTraits<VkImageLayout>::exist(value)) return false;
  *t = static_cast<VkImageLayout>(value);
  return true;
}

template <typename T>
inline bool AsArray(Json::Value* json_value, uint32_t count, T* values) {
  if (json_value->type() != Json::arrayValue || json_value->size() != count)
    return false;
  for (uint32_t i = 0; i < count; ++i) {
    if (!AsValue(&(*json_value)[i], values + i)) return false;
  }
  return true;
}

template <typename T, size_t N>
inline bool AsValue(Json::Value* json_value, T (*value)[N]) {
  return AsArray(json_value, N, *value);
}

template <size_t N>
inline bool AsValue(Json::Value* json_value, char (*value)[N]) {
  if (json_value->type() != Json::stringValue) return false;
  size_t len = json_value->asString().length();
  if (len >= N)
    return false;
  memcpy(*value, json_value->asString().c_str(), len);
  memset(*value + len, 0, N-len);
  return true;
}

template <typename T, typename = EnableForEnum<T>, typename = void>
inline bool AsValue(Json::Value* json_value, T* t) {
  uint32_t value = 0;
  if (!AsValue(json_value, &value))
      return false;
  if (!EnumTraits<T>::exist(value)) return false;
  *t = static_cast<T>(value);
  return true;
}

template <typename T>
inline bool AsValue(Json::Value* json_value, std::vector<T>* value) {
  if (json_value->type() != Json::arrayValue) return false;
  int size = json_value->size();
  value->resize(size);
  return AsArray(json_value, size, value->data());
}

template <typename F, typename S>
inline bool AsValue(Json::Value* json_value, std::pair<F, S>* value) {
  if (json_value->type() != Json::arrayValue || json_value->size() != 2)
    return false;
  return AsValue(&(*json_value)[0], &value->first) &&
         AsValue(&(*json_value)[1], &value->second);
}

template <typename F, typename S>
inline bool AsValue(Json::Value* json_value, std::map<F, S>* value) {
  if (json_value->type() != Json::arrayValue) return false;
  int size = json_value->size();
  for (int i = 0; i < size; ++i) {
    std::pair<F, S> elem;
    if (!AsValue(&(*json_value)[i], &elem)) return false;
    if (!value->insert(elem).second)
      return false;
  }
  return true;
}

template <typename T>
bool ReadValue(Json::Value* object, const char* key, T* value,
               std::string* errors) {
  Json::Value json_value = (*object)[key];
  if (!json_value) {
    if (errors)
      *errors = std::string(key) + " missing.";
    return false;
  }
  if (AsValue(&json_value, value)) return true;
  if (errors)
    *errors = std::string("Wrong type for ") + std::string(key) + ".";
  return false;
}

template <typename Visitor, typename T>
inline bool VisitForRead(Visitor* visitor, T* t) {
  return Iterate(visitor, t);
}

class JsonReaderVisitor {
 public:
  JsonReaderVisitor(Json::Value* object, std::string* errors)
      : object_(object), errors_(errors) {}

  template <typename T> bool Visit(const char* key, T* value) const {
    return ReadValue(object_, key, value, errors_);
  }

  template <typename T, uint32_t N>
  bool VisitArray(const char* key, uint32_t count, T (*value)[N]) {
    if (count > N)
      return false;
    Json::Value json_value = (*object_)[key];
    if (!json_value) {
      if (errors_)
        *errors_ = std::string(key) + " missing.";
      return false;
    }
    if (AsArray(&json_value, count, *value)) return true;
    if (errors_)
      *errors_ = std::string("Wrong type for ") + std::string(key) + ".";
    return false;
  }

  template <typename T>
  bool VisitArray(const char* key, uint32_t count, T *value) {
    Json::Value json_value = (*object_)[key];
    if (!json_value) {
      if (errors_)
        *errors_ = std::string(key) + " missing.";
      return false;
    }
    if (AsArray(&json_value, count, *value)) return true;
    if (errors_)
      *errors_ = std::string("Wrong type for ") + std::string(key) + ".";
    return false;
  }


 private:
  Json::Value* object_;
  std::string* errors_;
};

template <typename T, typename /*= EnableForStruct<T>*/>
bool AsValue(Json::Value* json_value, T* t) {
  if (json_value->type() != Json::objectValue) return false;
  JsonReaderVisitor visitor(json_value, nullptr);
  return VisitForRead(&visitor, t);
}


template <typename T> std::string VkTypeToJson(const T& t) {
  JsonWriterVisitor visitor;
  VisitForWrite(&visitor, t);
  return visitor.get_object().toStyledString();
}

template <typename T> bool VkTypeFromJson(const std::string& json,
                                          T* t,
                                          std::string* errors) {
  *t = T();
  Json::Value object(Json::objectValue);
  Json::CharReaderBuilder builder;
  builder["collectComments"] = false;
  std::unique_ptr<Json::CharReader> reader(builder.newCharReader());
  if (!reader->parse(json.data(), json.data() + json.size(), &object, errors)) {
    return false;
  }
  return AsValue(&object, t);
}

}  // anonymous namespace

std::string VkJsonInstanceToJson(const VkJsonInstance& instance) {
  return VkTypeToJson(instance);
}

bool VkJsonInstanceFromJson(const std::string& json,
                            VkJsonInstance* instance,
                            std::string* errors) {
  return VkTypeFromJson(json, instance, errors);
}

std::string VkJsonDeviceToJson(const VkJsonDevice& device) {
  return VkTypeToJson(device);
}

bool VkJsonDeviceFromJson(const std::string& json,
                          VkJsonDevice* device,
                          std::string* errors) {
  return VkTypeFromJson(json, device, errors);
};

std::string VkJsonImageFormatPropertiesToJson(
    const VkImageFormatProperties& properties) {
  return VkTypeToJson(properties);
}

bool VkJsonImageFormatPropertiesFromJson(const std::string& json,
                                         VkImageFormatProperties* properties,
                                         std::string* errors) {
  return VkTypeFromJson(json, properties, errors);
};
""")
    f.close()
  gencom.run_clang_format(genfile)


def gen_instance_cc():
  def write_list_resizing_codeblock(file, vk_version_mapping):
    code_block = util.generate_ext_independent_structs_list_resizing_logic(
      vk_version_mapping,
      VK_PROPERTIES_SETTER_LINE,
    )
    file.write(f"\n{code_block}\n")

  """Generates vkjson_instance.cc file.
  """
  genfile = os.path.join(os.path.dirname(__file__),
                         "..", "vkjson", "vkjson_instance.cc")

  with open(genfile, "w") as f:
    f.write(util.get_copyright_warnings())
    f.write("\n")

    f.write("""\
#ifndef VK_PROTOTYPES
#define VK_PROTOTYPES
#endif

#include "vkjson.h"

#include <algorithm>
#include <utility>

/*
 * This file is autogenerated by vkjson_generator.py. Do not edit directly.
 */
namespace {

bool EnumerateExtensions(const char* layer_name,
                         std::vector<VkExtensionProperties>* extensions) {
  VkResult result;
  uint32_t count = 0;
  result = vkEnumerateInstanceExtensionProperties(layer_name, &count, nullptr);
  if (result != VK_SUCCESS)
    return false;
  extensions->resize(count);
  result = vkEnumerateInstanceExtensionProperties(layer_name, &count,
                                                  extensions->data());
  if (result != VK_SUCCESS)
    return false;
  return true;
}

bool HasExtension(const char* extension_name,
                  const std::vector<VkExtensionProperties>& extensions) {
  return std::find_if(extensions.cbegin(), extensions.cend(),
                      [extension_name](const VkExtensionProperties& extension) {
                        return strcmp(extension.extensionName,
                                      extension_name) == 0;
                      }) != extensions.cend();
}
}  // anonymous namespace

VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
  VkJsonDevice device;

  uint32_t extension_count = 0;
  vkEnumerateDeviceExtensionProperties(physical_device, nullptr,
                                       &extension_count, nullptr);
  if (extension_count > 0) {
    device.extensions.resize(extension_count);
    vkEnumerateDeviceExtensionProperties(
        physical_device, nullptr, &extension_count, device.extensions.data());
  }

  uint32_t layer_count = 0;
  vkEnumerateDeviceLayerProperties(physical_device, &layer_count, nullptr);
  if (layer_count > 0) {
    device.layers.resize(layer_count);
    vkEnumerateDeviceLayerProperties(physical_device, &layer_count,
                                     device.layers.data());
  }

  VkPhysicalDeviceProperties2 properties = {
      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
      nullptr,
      {},
  };\n\n""")

    cc_code_properties = util.generate_vk_extension_structs_init_code(
    VK.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING["extensions"], "Properties")
    f.write(f'{cc_code_properties}\n')
    f.write(f'{VK_PROPERTIES_SETTER_LINE}\n')

    extension_list_resize_logic = util.generate_ext_dependent_structs_list_resizing_logic(
      VK_PROPERTIES_SETTER_LINE,
    )
    f.write(f'\n{extension_list_resize_logic}\n')
    f.write("""\

  device.properties = properties.properties;

  VkPhysicalDeviceFeatures2 features = {
      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
      nullptr,
      {},
  };\n\n""")

    cc_code_features = util.generate_vk_extension_structs_init_code(
      VK.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING["extensions"], "Features")
    f.write(f'{cc_code_features}\n')

    f.write("""\

  vkGetPhysicalDeviceFeatures2(physical_device, &features);
  device.features = features.features;

  vkGetPhysicalDeviceMemoryProperties(physical_device, &device.memory);

  uint32_t queue_family_count = 0;
  vkGetPhysicalDeviceQueueFamilyProperties(physical_device, &queue_family_count,
                                           nullptr);
  if (queue_family_count > 0) {
    device.queues.resize(queue_family_count);
    vkGetPhysicalDeviceQueueFamilyProperties(
        physical_device, &queue_family_count, device.queues.data());
  }

  VkFormatProperties format_properties = {};\n""")
    util.generate_format_range_map()
    f.write(util.generate_vk_format_init_code("VK_VERSION_1_0"))
    f.write(util.generate_vk_format_init_code())
    f.write("""\
    if (device.properties.apiVersion >= VK_API_VERSION_1_1) {\n""")
    f.write(util.generate_vk_format_init_code("VK_VERSION_1_1"))

    # Vulkan version data for VK_VERSION_1_1
    vk_version_data = VK.VULKAN_VERSIONS_AND_STRUCTS_MAPPING["VK_VERSION_1_1"]
    f.write(util.generate_vk_version_structs_initialization(vk_version_data, "Properties") + "\n")

    f.write("""\
    vkGetPhysicalDeviceProperties2(physical_device, &properties);\n\n""")
    write_list_resizing_codeblock(f, vk_version_data)

    features_initialization_code = util.generate_vk_version_structs_initialization(vk_version_data, "Features")
    f.write(features_initialization_code)

    f.write("""\

    vkGetPhysicalDeviceFeatures2(physical_device, &features);

    VkPhysicalDeviceExternalFenceInfo external_fence_info = {
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO, nullptr,
        VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT};
    VkExternalFenceProperties external_fence_properties = {};

    for (VkExternalFenceHandleTypeFlagBits handle_type =
             VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
         handle_type <= VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
         handle_type =
             static_cast<VkExternalFenceHandleTypeFlagBits>(handle_type << 1)) {
      external_fence_info.handleType = handle_type;
      vkGetPhysicalDeviceExternalFenceProperties(
          physical_device, &external_fence_info, &external_fence_properties);
      if (external_fence_properties.exportFromImportedHandleTypes ||
          external_fence_properties.compatibleHandleTypes ||
          external_fence_properties.externalFenceFeatures) {
        device.external_fence_properties.insert(
            std::make_pair(handle_type, external_fence_properties));
      }
    }

    VkPhysicalDeviceExternalSemaphoreInfo external_semaphore_info = {
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO, nullptr,
        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT};
    VkExternalSemaphoreProperties external_semaphore_properties = {};

    for (VkExternalSemaphoreHandleTypeFlagBits handle_type =
             VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
         handle_type <= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
         handle_type = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(
             handle_type << 1)) {
      external_semaphore_info.handleType = handle_type;
      vkGetPhysicalDeviceExternalSemaphoreProperties(
          physical_device, &external_semaphore_info,
          &external_semaphore_properties);
      if (external_semaphore_properties.exportFromImportedHandleTypes ||
          external_semaphore_properties.compatibleHandleTypes ||
          external_semaphore_properties.externalSemaphoreFeatures) {
        device.external_semaphore_properties.insert(
            std::make_pair(handle_type, external_semaphore_properties));
      }
    }
  }

  if (device.properties.apiVersion >= VK_API_VERSION_1_2) {\n""")
    f.write(util.generate_vk_format_init_code("VK_VERSION_1_2"))
    cc_code_properties_11, cc_code_features_11 = util.generate_vk_core_structs_init_code("Core11")
    cc_code_properties_12, cc_code_features_12 = util.generate_vk_core_structs_init_code("Core12")
    # Vulkan version data for VK_VERSION_1_2
    vk_version_data = VK.VULKAN_VERSIONS_AND_STRUCTS_MAPPING["VK_VERSION_1_2"]

    f.write(cc_code_properties_11)
    f.write(cc_code_properties_12)
    f.write(util.generate_vk_version_structs_initialization(vk_version_data, "Properties") + "\n")

    f.write(f"vkGetPhysicalDeviceProperties2(physical_device, &properties);\n\n")
    write_list_resizing_codeblock(f, vk_version_data)

    f.write(cc_code_features_11)
    f.write(cc_code_features_12)
    f.write(util.generate_vk_version_structs_initialization(vk_version_data, "Features"))

    f.write(f"vkGetPhysicalDeviceFeatures2(physical_device, &features);\n\n")
    f.write("""\
  }

  if (device.properties.apiVersion >= VK_API_VERSION_1_3) {\n""")
    f.write(util.generate_vk_format_init_code("VK_VERSION_1_3"))
    cc_code_properties_13, cc_code_features_13 = util.generate_vk_core_structs_init_code("Core13")
    cc_code_properties_14, cc_code_features_14 = util.generate_vk_core_structs_init_code("Core14")

    # Vulkan version data for VK_VERSION_1_3
    vk_version_data = VK.VULKAN_VERSIONS_AND_STRUCTS_MAPPING["VK_VERSION_1_3"]

    f.write(util.generate_vk_version_structs_initialization(vk_version_data, "Properties") + "\n")
    f.write(cc_code_properties_13)
    f.write(f"vkGetPhysicalDeviceProperties2(physical_device, &properties);\n\n")
    write_list_resizing_codeblock(f, vk_version_data)

    f.write(cc_code_features_13)
    f.write(f"{util.generate_vk_version_structs_initialization(vk_version_data, "Features")}\n")
    f.write(f"vkGetPhysicalDeviceFeatures2(physical_device, &features);\n\n")
    f.write("""\
  }

  if (device.properties.apiVersion >= VK_API_VERSION_1_4) {\n""")
    f.write(util.generate_vk_format_init_code("VK_VERSION_1_4"))

    # Vulkan version data for VK_VERSION_1_4
    vk_version_data = VK.VULKAN_VERSIONS_AND_STRUCTS_MAPPING["VK_VERSION_1_4"]
    f.write(util.generate_vk_version_structs_initialization(vk_version_data, "Properties") + "\n")
    f.write(cc_code_properties_14)
    f.write(f"vkGetPhysicalDeviceProperties2(physical_device, &properties);\n\n")
    write_list_resizing_codeblock(f, vk_version_data)

    f.write("""\
    if (device.core14.properties.copySrcLayoutCount > 0 || device.core14.properties.copyDstLayoutCount > 0 ) {
      if (device.core14.properties.copySrcLayoutCount > 0) {
        device.core14.copy_src_layouts.resize(device.core14.properties.copySrcLayoutCount);
        device.core14.properties.pCopySrcLayouts = device.core14.copy_src_layouts.data();
      }
      if (device.core14.properties.copyDstLayoutCount > 0) {
        device.core14.copy_dst_layouts.resize(device.core14.properties.copyDstLayoutCount);
        device.core14.properties.pCopyDstLayouts = device.core14.copy_dst_layouts.data();
      }
      vkGetPhysicalDeviceProperties2(physical_device, &properties);
    }
    \n""")
    f.write(cc_code_features_14)
    f.write(f"{util.generate_vk_version_structs_initialization(vk_version_data, "Features")}\n")
    f.write(f"vkGetPhysicalDeviceFeatures2(physical_device, &features);\n\n")
    f.write("""\
  }

  return device;
}

VkJsonInstance VkJsonGetInstance() {
  VkJsonInstance instance;
  VkResult result;
  uint32_t count;

  count = 0;
  result = vkEnumerateInstanceLayerProperties(&count, nullptr);
  if (result != VK_SUCCESS)
    return VkJsonInstance();
  if (count > 0) {
    std::vector<VkLayerProperties> layers(count);
    result = vkEnumerateInstanceLayerProperties(&count, layers.data());
    if (result != VK_SUCCESS)
      return VkJsonInstance();
    instance.layers.reserve(count);
    for (auto& layer : layers) {
      instance.layers.push_back(VkJsonLayer{layer, std::vector<VkExtensionProperties>()});
      if (!EnumerateExtensions(layer.layerName,
                               &instance.layers.back().extensions))
        return VkJsonInstance();
    }
  }

  if (!EnumerateExtensions(nullptr, &instance.extensions))
    return VkJsonInstance();

  const VkApplicationInfo app_info = {
      VK_STRUCTURE_TYPE_APPLICATION_INFO,
      nullptr,
      "vkjson_info",
      1,
      "",
      0,
      VK_API_VERSION_1_1,
  };
  VkInstanceCreateInfo instance_info = {
      VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
      nullptr,
      0,
      &app_info,
      0,
      nullptr,
      0,
      nullptr,
  };
  VkInstance vkinstance;
  result = vkCreateInstance(&instance_info, nullptr, &vkinstance);
  if (result != VK_SUCCESS)
    return VkJsonInstance();

  count = 0;
  result = vkEnumeratePhysicalDevices(vkinstance, &count, nullptr);
  if (result != VK_SUCCESS) {
    vkDestroyInstance(vkinstance, nullptr);
    return VkJsonInstance();
  }

  std::vector<VkPhysicalDevice> devices(count, VK_NULL_HANDLE);
  result = vkEnumeratePhysicalDevices(vkinstance, &count, devices.data());
  if (result != VK_SUCCESS) {
    vkDestroyInstance(vkinstance, nullptr);
    return VkJsonInstance();
  }

  std::map<VkPhysicalDevice, uint32_t> device_map;
  const uint32_t sz = devices.size();
  instance.devices.reserve(sz);
  for (uint32_t i = 0; i < sz; ++i) {
    device_map.insert(std::make_pair(devices[i], i));
    instance.devices.emplace_back(VkJsonGetDevice(devices[i]));
  }

  result = vkEnumerateInstanceVersion(&instance.api_version);
  if (result != VK_SUCCESS) {
    vkDestroyInstance(vkinstance, nullptr);
    return VkJsonInstance();
  }

  count = 0;
  result = vkEnumeratePhysicalDeviceGroups(vkinstance, &count, nullptr);
  if (result != VK_SUCCESS) {
    vkDestroyInstance(vkinstance, nullptr);
    return VkJsonInstance();
  }

  VkJsonDeviceGroup device_group;
  std::vector<VkPhysicalDeviceGroupProperties> group_properties;
  group_properties.resize(count);
  for (auto& properties : group_properties) {
    properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
    properties.pNext = nullptr;
  }
  result = vkEnumeratePhysicalDeviceGroups(vkinstance, &count,
                                           group_properties.data());
  if (result != VK_SUCCESS) {
    vkDestroyInstance(vkinstance, nullptr);
    return VkJsonInstance();
  }
  for (auto properties : group_properties) {
    device_group.properties = properties;
    for (uint32_t i = 0; i < properties.physicalDeviceCount; ++i) {
      device_group.device_inds.push_back(
          device_map[properties.physicalDevices[i]]);
    }
    instance.device_groups.push_back(device_group);
  }

  vkDestroyInstance(vkinstance, nullptr);
  return instance;
}

\n""")

    f.close()
  gencom.run_clang_format(genfile)